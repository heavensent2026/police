<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Traffic Team — Offline PWA</title>
  <meta name="theme-color" content="#0b0f1a" />
  <link rel="manifest" href="manifest.json" />
  <style>
    :root{
      --bg:#0b0f1a; --panel:#111a2b; --ink:#eaf1ff; --muted:#94a4c7;
      --barbg:#1b2742; --shadow: 0 20px 60px rgba(0,0,0,.45);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 40% -10%, #15254a 0%, var(--bg) 55%);
      color:var(--ink);
      min-height:100vh;
      display:flex; align-items:center; justify-content:center;
      padding:18px;
    }
    .app{
      width:min(980px, 100%);
      display:grid;
      grid-template-rows:auto 1fr auto;
      gap:14px;
    }
    header{display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .brand{display:flex; flex-direction:column; gap:2px;}
    .brand .title{font-weight:800; letter-spacing:.4px}
    .brand .sub{color:var(--muted); font-size:13px}
    .meta{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; color:var(--muted); font-size:13px;}
    .pill{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      padding:6px 10px;
      border-radius:999px;
      backdrop-filter: blur(8px);
    }

    .stats{
      background: rgba(17,26,43,.7);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      padding:12px 12px 10px;
      box-shadow: var(--shadow);
    }
    .statrow{
      display:grid;
      grid-template-columns: 110px 1fr 44px;
      gap:10px;
      align-items:center;
      margin:6px 0;
    }
    .label{font-size:12px; color:var(--muted); letter-spacing:.6px; text-transform:uppercase}
    .bar{
      height:12px;
      background: var(--barbg);
      border-radius:999px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.08);
    }
    .fill{
      height:100%;
      width:50%;
      border-radius:999px;
      background: linear-gradient(90deg, rgba(106,168,255,.95), rgba(91,255,177,.85));
      transition: width .25s ease;
    }
    .fill.heat{
      background: linear-gradient(90deg, rgba(255,92,122,.75), rgba(255,196,92,.85));
    }
    .value{font-variant-numeric: tabular-nums; text-align:right; color: rgba(234,241,255,.85); font-size:13px;}

    .card{
      background: rgba(17,26,43,.78);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: calc(var(--radius) + 6px);
      padding: 20px 18px;
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      gap:14px;
      min-height: 340px;
      position:relative;
      overflow:hidden;
    }
    .card:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(700px 260px at 20% 0%, rgba(106,168,255,.22), transparent 60%),
                  radial-gradient(700px 260px at 80% 20%, rgba(255,92,122,.14), transparent 60%);
      pointer-events:none;
      opacity:.9;
    }
    .card > *{position:relative}
    .scene{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:13px;
    }
    .scene strong{color:rgba(234,241,255,.88)}
    .prompt{
      font-size: clamp(18px, 2.4vw, 26px);
      line-height:1.25;
      font-weight:750;
      letter-spacing:.2px;
      padding: 6px 2px 0;
    }
    .hint{color: var(--muted); font-size:13px; line-height:1.35; margin-top:-2px;}
    .choices{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:auto;
    }
    button{
      appearance:none;
      border:none;
      border-radius: 16px;
      padding: 14px 14px;
      font-weight:700;
      font-size:15px;
      color:var(--ink);
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      cursor:pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
      min-height:56px;
    }
    button:active{transform: translateY(1px) scale(.99)}
    .left:hover{background: rgba(91,255,177,.10); border-color: rgba(91,255,177,.25)}
    .right:hover{background: rgba(255,92,122,.10); border-color: rgba(255,92,122,.25)}
    .footer{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; color:var(--muted); font-size:13px;}
    .footer .actions{display:flex; gap:8px; flex-wrap:wrap}
    .linkbtn{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      color: rgba(234,241,255,.90);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight:700;
      font-size:13px;
      cursor:pointer;
    }
    .toast{
      position:fixed; bottom:16px; left:50%;
      transform: translateX(-50%);
      background: rgba(10,14,26,.9);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(234,241,255,.92);
      padding: 10px 12px;
      border-radius: 999px;
      box-shadow: 0 18px 60px rgba(0,0,0,.5);
      opacity:0; pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      font-size:13px;
      backdrop-filter: blur(10px);
      max-width:min(720px, 92vw);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.show{opacity:1; transform: translateX(-50%) translateY(-2px)}
    @media (max-width: 680px){
      .statrow{grid-template-columns: 98px 1fr 42px}
      .choices{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="title">Traffic Team</div>
        <div class="sub">Offline PWA • patrol stance loop</div>
      </div>
      <div class="meta">
        <div class="pill" id="pillTime">—</div>
        <div class="pill" id="pillZone">—</div>
        <div class="pill" id="pillShift">—</div>
      </div>
    </header>

    <section class="stats" aria-label="Stats">
      <div class="statrow">
        <div class="label">Public</div>
        <div class="bar"><div class="fill" id="barPublic"></div></div>
        <div class="value" id="valPublic">50</div>
      </div>
      <div class="statrow">
        <div class="label">Department</div>
        <div class="bar"><div class="fill" id="barDept"></div></div>
        <div class="value" id="valDept">50</div>
      </div>
      <div class="statrow">
        <div class="label">Health</div>
        <div class="bar"><div class="fill" id="barHealth"></div></div>
        <div class="value" id="valHealth">50</div>
      </div>
      <div class="statrow">
        <div class="label">Heat</div>
        <div class="bar"><div class="fill heat" id="barHeat"></div></div>
        <div class="value" id="valHeat">50</div>
      </div>
    </section>

    <main class="card" aria-live="polite">
      <div class="scene">
        <div><strong id="sceneLine">—</strong></div>
        <div id="streakLine">—</div>
      </div>
      <div class="prompt" id="prompt">Loading…</div>
      <div class="hint" id="hint">—</div>
      <div class="choices">
        <button class="left" id="btnLeft">—</button>
        <button class="right" id="btnRight">—</button>
      </div>
    </main>

    <div class="footer">
      <div id="footerLine">—</div>
      <div class="actions">
        <button class="linkbtn" id="btnSave">Save</button>
        <button class="linkbtn" id="btnNew">New Run</button>
        <button class="linkbtn" id="btnExport">Export Save</button>
        <button class="linkbtn" id="btnImport">Import Save</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">—</div>

<script>
(() => {
  // ---------- utils ----------
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const nowISO = () => new Date().toISOString();

  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }
  const pick = (arr, rng) => arr[Math.floor(rng() * arr.length)];
  const chance = (rng, p) => rng() < p;
  const fmt = (tpl, ctx) => tpl.replace(/\{(\w+)\}/g, (_, k) => (ctx && ctx[k] != null) ? String(ctx[k]) : `{${k}}`);

  // ---------- zones ----------
  const ZONES_DAY = ["US-17","Mount Pleasant","West Ashley","Summerville","I-26","I-526","North Charleston"];
  const ZONES_NIGHT = ["I-26","I-526","US-17","North Charleston","West Ashley"];

  const ZONE_PROFILES = {
    "I-26": { topicMult:{radar:1.35, reckless:1.25, dui:1.20, crash:1.15, pursuit:1.15, community:0.75, admin:0.85} },
    "I-526":{ topicMult:{radar:1.30, reckless:1.20, dui:1.15, crash:1.15, pursuit:1.10, community:0.80, admin:0.90} },
    "US-17":{ topicMult:{stop:1.20, radar:1.10, dui:1.05, crash:1.05, community:1.00, admin:0.95, pursuit:0.90, reckless:1.05} },
    "Mount Pleasant":{ topicMult:{community:1.35, stop:1.15, admin:1.05, radar:0.95, reckless:0.80, pursuit:0.60, crash:0.85, dui:0.90} },
    "Summerville":{ topicMult:{stop:1.20, crash:1.10, community:1.05, radar:1.05, admin:0.95, reckless:0.95, pursuit:0.80, dui:1.00} },
    "West Ashley":{ topicMult:{stop:1.20, community:1.10, dui:1.10, admin:1.05, radar:0.95, crash:1.00, reckless:0.95, pursuit:0.85} },
    "North Charleston":{ topicMult:{stop:1.25, reckless:1.15, pursuit:1.20, admin:1.05, crash:1.05, dui:1.10, community:0.85, radar:1.05} }
  };
  const zoneProfile = (z) => ZONE_PROFILES[z] || {topicMult:{}};

  // ---------- patrol stances (THE LOOP) ----------
  const STANCES = [
    {
      key:"radar",
      label:"Radar & Pace",
      // boosts radar/speeding + lane; mild heat
      mult:{ speeding:1.55, lane:1.20, phone:1.05, plate:1.05, dui:0.85, crash:0.90, hazard:0.90, moveover:1.00, tint:1.05, load:1.00 },
      passive:{ public:-0.05, dept:+0.10, heat:+0.10, health:-0.05 }
    },
    {
      key:"visible",
      label:"Visible Patrol",
      // more stops like phone/plate/moveover; less high intensity
      mult:{ phone:1.35, plate:1.30, moveover:1.25, tint:1.20, speeding:1.05, lane:1.10, dui:0.90, crash:1.05, hazard:1.05, load:1.05 },
      passive:{ public:+0.10, dept:-0.05, heat:-0.05, health:-0.03 }
    },
    {
      key:"dui",
      label:"DUI Focus",
      mult:{ dui:1.75, lane:1.10, speeding:1.10, crash:1.10, phone:0.85, plate:0.95, moveover:0.95, tint:0.90, hazard:1.00, load:0.95 },
      passive:{ public:-0.05, dept:+0.15, heat:+0.15, health:-0.10 }
    },
    {
      key:"crash",
      label:"Crash Cover",
      mult:{ crash:1.55, hazard:1.50, load:1.15, lane:1.05, speeding:0.90, dui:1.05, phone:0.90, plate:0.95, moveover:1.05, tint:0.90 },
      passive:{ public:+0.12, dept:-0.05, heat:-0.10, health:-0.06 }
    },
    {
      key:"proactive",
      label:"Proactive Enforcement",
      mult:{ speeding:1.25, lane:1.25, plate:1.15, tint:1.15, phone:1.10, moveover:1.05, dui:1.05, crash:0.95, hazard:0.90, load:1.05 },
      passive:{ public:-0.12, dept:+0.18, heat:+0.22, health:-0.12 }
    },
    {
      key:"low",
      label:"Low-Profile Presence",
      mult:{ crash:1.10, hazard:1.10, phone:0.90, plate:0.90, tint:0.90, speeding:0.85, lane:0.90, dui:0.95, moveover:1.00, load:1.00 },
      passive:{ public:+0.08, dept:-0.12, heat:-0.22, health:+0.05 }
    }
  ];
  const stanceByKey = (k) => STANCES.find(s => s.key === k) || STANCES[1];

  // Stance cards show only 2 options at a time (fits your UI).
  const STANCE_PAIRS = [
    ["radar","visible"],
    ["dui","crash"],
    ["proactive","low"],
  ];

  // ---------- readable content pools ----------
  const VEH = {
    sedan:["silver sedan","white Camry","black Altima","gray Accord","red compact"],
    suv:["dark SUV","white crossover","black Tahoe","gray Explorer","blue Jeep"],
    truck:["white pickup","work truck","black Ram","older F-150","lifted truck"],
    bike:["sport bike","black motorcycle","loud cruiser"],
    van:["white van","delivery van","old minivan"]
  };

  const REASONS = {
    speeding:["radar hits {over} over","paced at {over} over","fast lane run at {over} over"],
    lane:["crossed the line twice","drifted into the next lane","failed to maintain lane"],
    tint:["windows are too dark","front tint looks illegal","can’t see the driver at all"],
    plate:["no rear plate","tag is unreadable","plate cover is blocking it"],
    phone:["phone in hand","head down at the light","texting while rolling"],
    moveover:["didn’t move over for your lights","blew past a shoulder stop","ignored the open lane"],
    dui:["can’t hold centerline","speed keeps changing","braking for no reason"],
    load:["unsecured load shifting","strap flapping loose","debris bouncing in the bed"],
    hazard:["debris in lane","tire tread in roadway","ladder in the travel lane"],
    crash:["rear-end, both drivable","two-car crash, tempers hot","minor crash, traffic backing up"],

    // follow-ups that always make sense
    court:["court date set for your stop","ADA asks for a clean timeline","defense attorney wants details"],
    review:["supervisor flags your footage","complaint gets routed for review","policy review meeting scheduled"]
  };

  const DRIVER = {
    demeanor:["calm","defensive","angry","nervous","too friendly","stone quiet"],
    hands:["hands visible","hands low","one hand shaking","grip tight"],
    eyes:["won’t look up","stares hard","keeps checking mirrors","blinks slow"]
  };

  // ---------- effects ----------
  const FX = {
    warn:   {public:+2, dept:-1, heat:-1, health: 0},
    cite:   {public:-1, dept:+2, heat:+1, health: 0},
    search: {public:-2, dept:+2, heat:+2, health:-1},
    arrest: {public: 0, dept:+3, heat:+2, health:-1},
    calm:   {public:+2, dept:-1, heat:-2, health: 0},
    hard:   {public:-2, dept:+2, heat:+2, health:-1},
    safe:   {public:+1, dept:-1, heat:-2, health: 0},
    chase:  {public:-2, dept:+2, heat:+3, health:-2},
    paper:  {public: 0, dept:+2, heat:+1, health:-1},
    corners:{public:-1, dept:-2, heat:+2, health: 0},
  };
  function fxFlavor(fx){
    if(fx === FX.warn) return "Warning. Quick reset.";
    if(fx === FX.cite) return "Ticket. Clean but sour.";
    if(fx === FX.search) return "You dig deeper. Tension rises.";
    if(fx === FX.arrest) return "Arrest. Paperwork grows teeth.";
    if(fx === FX.calm) return "Calm tone. Scene loosens.";
    if(fx === FX.hard) return "Firm stop. Scene tightens.";
    if(fx === FX.safe) return "You back off. Everyone lives.";
    if(fx === FX.chase) return "You stay in it. Risk spikes.";
    if(fx === FX.paper) return "Clean report. You can breathe.";
    if(fx === FX.corners) return "Corners cut. It’ll come back.";
    return "Choice locked.";
  }

  // ---------- chain model ----------
  const CORE_STAGES = ["A","B","C","D","E"];
  const PURSUIT_STAGES = ["P1","P2","P3","P4","P5","P6","P7","P8"];

  const CHAINS = [
    {key:"speeding", label:"Speeding", topic:["radar","stop"], intensity:"mid"},
    {key:"lane", label:"Lane Violation", topic:["stop"], intensity:"mid"},
    {key:"tint", label:"Tint", topic:["stop"], intensity:"low"},
    {key:"plate", label:"Plate/Tag", topic:["stop"], intensity:"mid"},
    {key:"phone", label:"Distracted", topic:["stop"], intensity:"low"},
    {key:"moveover", label:"Move Over", topic:["community","stop"], intensity:"mid"},
    {key:"dui", label:"DUI Suspicion", topic:["dui","stop"], intensity:"high", nightBias:true},
    {key:"load", label:"Unsecured Load", topic:["stop"], intensity:"mid"},
    {key:"hazard", label:"Road Hazard", topic:["crash"], intensity:"low"},
    {key:"crash", label:"Crash", topic:["crash"], intensity:"mid"},
    // follow-ups (scheduled)
    {key:"court", label:"Court", topic:["admin"], intensity:"mid", scheduledOnly:true},
    {key:"review", label:"Review", topic:["admin"], intensity:"mid", scheduledOnly:true},
    // pursuit (injected only)
    {key:"pursuit", label:"Pursuit", topic:["pursuit","reckless"], intensity:"high", nightBias:true, isPursuit:true}
  ];
  const getChain = (k) => CHAINS.find(c => c.key === k) || CHAINS[0];

  // ---------- context ----------
  function makeCtx(chainKey, S, rng){
    const isNight = S.isNight;
    const over = [10,15,20,25,30][Math.floor(rng()*5)];
    const traffic = pick(["light traffic","moderate traffic","heavy traffic"], rng);
    const vehClass =
      (chainKey === "load") ? "truck" :
      (chainKey === "dui") ? pick(["sedan","suv","van"], rng) :
      (chainKey === "speeding") ? pick(["sedan","suv","truck","bike"], rng) :
      pick(["sedan","suv"], rng);

    const vehicle = pick(VEH[vehClass], rng);

    return {
      zone: S.zone,
      isNight,
      over,
      traffic,
      vehicle,
      demeanor: pick(DRIVER.demeanor, rng),
      hands: pick(DRIVER.hands, rng),
      eyes: pick(DRIVER.eyes, rng)
    };
  }

  // ---------- builders ----------
  function canPursue(S){
    return (S.heat >= 48) || (S.streakEnforce >= 3);
  }

  // Stance selection card (two-choice, fits your UI)
  function buildStanceCard(pairIndex, S){
    const pair = STANCE_PAIRS[pairIndex % STANCE_PAIRS.length];
    const L = stanceByKey(pair[0]);
    const R = stanceByKey(pair[1]);

    const t = `You’ve got a block in ${S.zone}. How are you working it?`;
    return {
      kind:"stance",
      t,
      hint:`Patrol stance • pick a mode for the next 6 turns`,
      L:{txt:L.label, stanceKey:L.key},
      R:{txt:R.label, stanceKey:R.key},
    };
  }

  function buildCore(chainKey, stage, v, ctx, S){
    const chain = getChain(chainKey);
    const tag = [...chain.topic, chain.intensity, ctx.isNight ? "night" : "day"];
    const reasonArr = REASONS[chainKey] || ["something feels off","something doesn’t add up","something catches your eye"];
    const reason = fmt(reasonArr[v] || reasonArr[0], ctx);

    const step = CORE_STAGES.indexOf(stage) + 1;

    // Special handling for scheduled follow-ups (court/review) so they always make sense
    const isFollowup = (chainKey === "court" || chainKey === "review");

    if(stage === "A"){
      const t = isFollowup
        ? `${reason}. It’s back in your lap.`
        : `${ctx.vehicle} — ${reason}. (${ctx.traffic})`;
      return {
        tag, step, total:5,
        t,
        L:{txt: isFollowup ? "Prep properly." : "Stay visible. No stop.", fx: isFollowup ? FX.paper : FX.safe, lead:{stage: isFollowup ? "B" : "E"} },
        R:{txt: isFollowup ? "Rush it." : "Stop it.", fx: isFollowup ? FX.corners : FX.cite, lead:{stage:"B"}}
      };
    }

    if(stage === "B"){
      const t = isFollowup
        ? "You pull reports/footage. The details matter more than you want."
        : `Window down. Driver is ${ctx.demeanor}. ${ctx.hands}. ${ctx.eyes}.`;
      return {
        tag, step, total:5,
        t,
        L:{txt: isFollowup ? "Stick to facts." : "Explain it, keep it calm.", fx: isFollowup ? FX.calm : FX.calm, lead:{stage:"C"}},
        R:{txt: isFollowup ? "Defend hard." : "Direct commands, tight stop.", fx: isFollowup ? FX.hard : FX.hard, lead:{stage:"C"}}
      };
    }

    if(stage === "C"){
      const decisions = {
        speeding: ["Warning and clear.", "Write the ticket."],
        lane: ["Fix-it warning.", "Cite for lane violation."],
        tint: ["Meter it and warn.", "Cite for tint."],
        plate: ["Run it slow, verify.", "Call backup, hold them."],
        phone: ["Educate + warning.", "Cite for phone."],
        moveover: ["Verbal warning.", "Cite + explain danger."],
        dui: ["Run SFST.", "Call backup now."],
        load: ["Make them secure it.", "Cite + tow if needed."],
        hazard: ["Block and clear it.", "Call DOT, keep rolling."],
        crash: ["Slow it down, sort it.", "Write it quick, clear lanes."],
        court: ["Answer plainly.", "Talk policy only."],
        review: ["Own mistakes.", "Deny everything."]
      };
      const pair = decisions[chainKey] || ["Handle it soft.", "Handle it hard."];
      const t = isFollowup ? "What’s your approach?" : "What’s your play?";
      const heavy = (chainKey === "dui" || chainKey === "plate" || isFollowup);
      return {
        tag, step, total:5,
        t,
        L:{txt: pair[0], fx: heavy ? FX.paper : FX.warn, lead:{stage:"D"}},
        R:{txt: pair[1], fx: heavy ? FX.corners : FX.cite, lead:{stage:"D"}}
      };
    }

    if(stage === "D"){
      const canRun = ["dui","plate","speeding","lane"].includes(chainKey);
      const out = isFollowup ? [
        "They push back. Your timeline has to hold.",
        "A question lands like a trap. Everyone watches your face.",
        "They bring up a detail you don’t remember."
      ] : [
        "They comply. You can finish this clean.",
        "They argue and stall. People slow down to watch.",
        canRun ? "They hesitate… then the engine tone changes." : "They hesitate, watching your hands."
      ];
      const t = out[v];

      if(!isFollowup && v === 2 && canRun){
        return {
          tag, step, total:5,
          t,
          L:{txt:"Terminate. Let it go.", fx:FX.safe, lead:{stage:"E"}},
          R:{txt:"Stay with it.", fx:FX.chase, lead:{stage:"E", pursue:true}}
        };
      }

      return {
        tag, step, total:5,
        t,
        L:{txt: isFollowup ? "Stay calm, finish." : "De-escalate and finish.", fx:FX.calm, lead:{stage:"E"}},
        R:{txt: isFollowup ? "Hold firm, finish." : "Hold the line, finish.", fx:FX.hard, lead:{stage:"E"}}
      };
    }

    if(stage === "E"){
      const t = isFollowup
        ? "You walk out with your stomach tight. It’s not over, but it’s done for now."
        : "You clear the scene. Radio is already chirping again.";
      return {
        tag, step, total:5,
        t,
        L:{txt:"Write it clean.", fx:FX.paper, lead:null},
        R:{txt:"Cut corners.", fx:FX.corners, lead:null}
      };
    }

    return {tag, step, total:5, t:"—", L:{txt:"Continue", fx:{}, lead:null}, R:{txt:"Continue", fx:{}, lead:null}};
  }

  function buildPursuit(stage, v, ctx){
    const step = PURSUIT_STAGES.indexOf(stage) + 1;

    const P = {
      P1:[
        `They take off. ${ctx.vehicle} pulls away before your siren finishes a sentence.`,
        `The stop turns into a run. ${ctx.traffic} means every move matters.`,
        `They won’t stop. You feel policy tightening as speed rises.`
      ],
      P2:[
        `They cut lanes toward an exit. One mistake here ruins strangers.`,
        `They ride the shoulder and spray grit. Your tires chatter.`,
        `They dive into traffic like they’re immune. You’re not.`
      ],
      P3:[
        `Dispatch wants updates. You give them calm while your pulse lies.`,
        `Units are “en route.” That can mean now or never.`,
        `Air tries to get eyes. You still have to survive the next corner.`
      ],
      P4:[
        `They blow a light. A civilian hesitates at the worst moment.`,
        `Near miss. You taste metal in your mouth for a second.`,
        `A turn comes up too fast. The road is not forgiving tonight.`
      ],
      P5:[
        `Tactics: spikes are possible, but the location is messy.`,
        `Tactics: PIT could work, but the surface is wrong.`,
        `Tactics: you have seconds to pick “safe” or “effective.”`
      ],
      P6:[
        `They clip a curb and keep going. The car is damaged and still dangerous.`,
        `They wobble hard. You sense the end coming, clean or ugly.`,
        `They brake-check. Your whole body goes tight.`
      ],
      P7:[
        `Door pops. They run. Darkness eats the gaps.`,
        `They bail near ${ctx.zone}. You hear a fence rattle.`,
        `They disappear between buildings. Contain or chase.`
      ],
      P8:[
        `It ends. Now it’s paperwork, statements, and second-guessing.`,
        `After the adrenaline, your hands shake in slow motion.`,
        `You replay choices like dashcam footage you can’t turn off.`
      ]
    };

    const t = P[stage][v] || "The pursuit evolves.";

    if(stage === "P8"){
      return {
        tag:["pursuit","high", ctx.isNight ? "night":"day"], step, total:8,
        t,
        L:{txt:"Write it clean.", fx:FX.paper, lead:null},
        R:{txt:"Cut corners.", fx:FX.corners, lead:null}
      };
    }

    if(stage === "P5"){
      return {
        tag:["pursuit","high", ctx.isNight ? "night":"day"], step, total:8,
        t,
        L:{txt:"Choose the safe tactic.", fx:FX.safe, lead:{next:true}},
        R:{txt:"Choose the aggressive tactic.", fx:FX.chase, lead:{next:true}}
      };
    }

    if(stage === "P7"){
      return {
        tag:["pursuit","high", ctx.isNight ? "night":"day"], step, total:8,
        t,
        L:{txt:"Contain and wait for units.", fx:FX.safe, lead:{next:true}},
        R:{txt:"Go after them on foot.", fx:FX.hard, lead:{next:true}}
      };
    }

    return {
      tag:["pursuit","high", ctx.isNight ? "night":"day"], step, total:8,
      t,
      L:{txt:"Terminate. Fall back.", fx:FX.safe, lead:{next:true}},
      R:{txt:"Stay with it.", fx:FX.chase, lead:{next:true}}
    };
  }

  // ---------- state ----------
  const KEY = "traffic-team-save-v5";
  const DEFAULT = () => ({
    v:5,
    seed: Math.floor(Date.now()/1000) ^ 0xA55A55A,
    turn:0,
    public:50, dept:50, health:50, heat:45,
    day:1, shift:1, isNight:false, zone:"US-17",
    streakEnforce:0, streakDeEsc:0,

    // stance loop
    stanceKey:"visible",
    stanceTurnsLeft:0,     // forces stance pick at start
    stancePairIndex:0,     // cycles pairs

    caseSeq:0,
    queue:[],              // {kind:"case", caseId, chainKey, stageIndex, stageList, v, ctx} OR {kind:"stance", pairIndex}
    scheduled:[],          // {runAtTurn, chainKey, ctx, reason}
    recentKeys:[],
    startedAt:nowISO(),
    updatedAt:nowISO(),
  });

  function load(){
    try{
      const raw = localStorage.getItem(KEY);
      if(!raw) return null;
      const s = JSON.parse(raw);
      if(!s || s.v !== 5) return null;
      return s;
    }catch{ return null; }
  }
  function save(S){
    S.updatedAt = nowISO();
    localStorage.setItem(KEY, JSON.stringify(S));
  }

  let S = load() || DEFAULT();
  let rng = mulberry32(S.seed);

  // ---------- UI ----------
  const el = (id)=>document.getElementById(id);
  const barPublic = el("barPublic"), barDept = el("barDept"), barHealth = el("barHealth"), barHeat = el("barHeat");
  const valPublic = el("valPublic"), valDept = el("valDept"), valHealth = el("valHealth"), valHeat = el("valHeat");
  const prompt = el("prompt"), hint = el("hint"), sceneLine = el("sceneLine"), streakLine = el("streakLine");
  const btnLeft = el("btnLeft"), btnRight = el("btnRight");
  const pillTime = el("pillTime"), pillZone = el("pillZone"), pillShift = el("pillShift");
  const footerLine = el("footerLine");
  const toast = el("toast");

  function toastMsg(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(()=>toast.classList.remove("show"), 1700);
  }

  function formatTime(){
    const dow = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"][((S.day-1)%7+7)%7];
    const shiftName = S.isNight ? "Night Shift" : "Day Shift";
    return {dow, shiftName};
  }
  function setZone(){
    const pool = S.isNight ? ZONES_NIGHT : ZONES_DAY;
    const roll = rng();
    if(roll < 0.55) return S.zone;
    return pick(pool, rng);
  }
  function tickTime(){
    if(S.turn > 0 && S.turn % 14 === 0){
      S.shift += 1;
      S.isNight = !S.isNight;
      S.zone = setZone();
      // Force a stance pick at shift change
      S.stanceTurnsLeft = 0;
      toastMsg(S.isNight ? "Night shift." : "Day shift.");
    }
    if(S.turn > 0 && S.turn % 28 === 0) S.day = ((S.day % 7) + 1);
    if(S.turn > 0 && S.turn % 14 === 0){
      S.health = clamp(S.health - (S.isNight ? 1 : 0), 0, 100);
      S.heat = clamp(S.heat + (S.isNight ? 1 : -1), 0, 100);
    }
  }

  // ---------- stance mechanics ----------
  function stancePassiveTick(){
    const st = stanceByKey(S.stanceKey);
    S.public = clamp(S.public + st.passive.public, 0, 100);
    S.dept   = clamp(S.dept   + st.passive.dept,   0, 100);
    S.heat   = clamp(S.heat   + st.passive.heat,   0, 100);
    S.health = clamp(S.health + st.passive.health, 0, 100);
  }

  function ensureStanceCard(){
    // stance card appears when empty, when forced, or every 6 turns
    if(S.stanceTurnsLeft <= 0){
      // Put stance choice at FRONT so you feel like you’re deciding the patrol loop
      S.queue.unshift({kind:"stance", pairIndex: S.stancePairIndex});
      S.stancePairIndex = (S.stancePairIndex + 1) % STANCE_PAIRS.length;
    }
  }

  function setStance(stanceKey){
    S.stanceKey = stanceKey;
    S.stanceTurnsLeft = 6;
    const st = stanceByKey(stanceKey);
    toastMsg(`Stance: ${st.label}`);
  }

  // ---------- selection weighting (zone + stance + heat) ----------
  function weightChain(chain){
    if(chain.isPursuit) return 0.0001;          // never random
    if(chain.scheduledOnly) return 0.01;        // never random

    let w = 1;

    // Heat -> intensity
    if(chain.intensity === "low")  w *= (S.heat < 50) ? 1.20 : 0.80;
    if(chain.intensity === "mid")  w *= (S.heat < 40) ? 0.95 : 1.15;
    if(chain.intensity === "high") w *= (S.heat >= 52) ? 1.30 : 0.55;

    // night -> DUI
    if(S.isNight && chain.nightBias) w *= 1.30;

    // zone profile
    const prof = zoneProfile(S.zone);
    for(const t of chain.topic){
      if(prof.topicMult[t] != null) w *= prof.topicMult[t];
    }

    // stance profile (THIS is the patrol loop payoff)
    const st = stanceByKey(S.stanceKey);
    if(st.mult[chain.key] != null) w *= st.mult[chain.key];

    // cooldown
    if(S.recentKeys.includes(chain.key)) w *= 0.60;

    return w;
  }

  function pickChain(){
    const pool = CHAINS.filter(c => !c.isPursuit && !c.scheduledOnly);
    let total = 0;
    const ws = pool.map(c => (total += weightChain(c), weightChain(c)));
    let r = rng() * total;
    for(let i=0;i<pool.length;i++){
      r -= ws[i];
      if(r <= 0) return pool[i];
    }
    return pool[0];
  }

  // ---------- scheduling ----------
  function schedule(chainKey, ctx, runAtTurn, reason){
    S.scheduled.push({chainKey, ctx, runAtTurn, reason});
    S.scheduled.sort((a,b)=>a.runAtTurn - b.runAtTurn);
    if(S.scheduled.length > 20) S.scheduled = S.scheduled.slice(0,20);
  }

  function flushScheduled(){
    const due = [];
    const keep = [];
    for(const it of S.scheduled){
      if(it.runAtTurn <= S.turn) due.push(it);
      else keep.push(it);
    }
    S.scheduled = keep;
    for(const it of due){
      startChain(it.chainKey, it.ctx, true);
      toastMsg(it.reason || "A case comes back.");
    }
  }

  // ---------- queue / chains ----------
  function startChain(chainKey, ctxOverride=null){
    const chain = getChain(chainKey);
    const caseId = ++S.caseSeq;

    const stageList = chain.isPursuit ? PURSUIT_STAGES : CORE_STAGES;
    const ctx = ctxOverride || makeCtx(chain.key, S, rng);

    for(let i=0;i<stageList.length;i++){
      const v = Math.floor(rng()*3);
      S.queue.push({kind:"case", caseId, chainKey: chain.key, stageIndex:i, stageList, v, ctx});
    }

    if(!chain.isPursuit && !chain.scheduledOnly){
      S.recentKeys.unshift(chain.key);
      S.recentKeys = S.recentKeys.slice(0, 7);
    }
  }

  function injectPursuit(ctx){
    const snap = S.queue.slice(0);
    S.queue.length = 0;
    startChain("pursuit", ctx);
    S.queue.push(...snap);
  }

  // ---------- engine ----------
  let current = null;

  function applyFx(fx){
    if(!fx) return;
    S.public = clamp(S.public + (fx.public||0), 0, 100);
    S.dept   = clamp(S.dept   + (fx.dept||0),   0, 100);
    S.health = clamp(S.health + (fx.health||0), 0, 100);
    S.heat   = clamp(S.heat   + (fx.heat||0),   0, 100);
  }

  function endCheck(){
    const dead =
      (S.health <= 0) ? "You go down mid-shift. The road keeps moving without you." :
      (S.dept   <= 0) ? "You’re pulled off traffic. Your run ends behind a desk." :
      (S.public <= 0) ? "The public turns on you. Every stop becomes a fight. Reassigned." :
      (S.heat   <= 0) ? "You lose momentum and burn out quietly." :
      null;

    if(dead){
      prompt.textContent = dead;
      hint.textContent = "Tap New Run to start again.";
      btnLeft.textContent = "New Run";
      btnRight.textContent = "Export Save";
      btnLeft.onclick = () => newRun();
      btnRight.onclick = () => exportSave();
      return true;
    }

    if(S.heat >= 100){
      S.heat = 95;
      S.health = clamp(S.health - 2, 0, 100);
      S.public = clamp(S.public - 2, 0, 100);
      toastMsg("Heat peaks. Everything gets sharper.");
    }
    return false;
  }

  function nextCard(initial=false){
    tickTime();
    S.zone = setZone();

    flushScheduled();

    // stance tick happens as the world moves (gamey “mode” feel)
    stancePassiveTick();

    // if stance expired, force stance choice next
    ensureStanceCard();

    if(S.queue.length === 0){
      // If no stance card is due, start a case chain
      const c = pickChain();
      startChain(c.key);

      // high heat: sometimes two cases overlap (pressure)
      if(S.heat >= 60 && chance(rng, 0.16)) startChain(pickChain().key);
    }

    const item = S.queue.shift();

    // stance card
    if(item.kind === "stance"){
      const sc = buildStanceCard(item.pairIndex, S);
      current = {kind:"stance", card: sc, item};

      prompt.textContent = sc.t;
      sceneLine.textContent = `${S.isNight ? "Night" : "Day"} • ${S.zone}`;
      hint.textContent = sc.hint;

      btnLeft.textContent = sc.L.txt;
      btnRight.textContent = sc.R.txt;
      btnLeft.onclick = () => choose("L");
      btnRight.onclick = () => choose("R");

      if(!initial) save(S);
      render();
      return;
    }

    // case card
    const chain = getChain(item.chainKey);
    const stage = item.stageList[item.stageIndex];

    let card;
    if(chain.isPursuit){
      card = buildPursuit(stage, item.v, item.ctx);
    } else {
      card = buildCore(item.chainKey, stage, item.v, item.ctx, S);
    }

    current = {kind:"case", card, item, chain, stage};

    prompt.textContent = card.t;
    sceneLine.textContent = `${S.isNight ? "Night" : "Day"} • ${item.ctx.zone}`;

    const st = stanceByKey(S.stanceKey).label;
    hint.textContent = `${chain.label} • Step ${card.step}/${card.total} • Stance: ${st} (${S.stanceTurnsLeft} left)`;

    btnLeft.textContent = card.L.txt;
    btnRight.textContent = card.R.txt;
    btnLeft.onclick = () => choose("L");
    btnRight.onclick = () => choose("R");

    if(!initial) save(S);
    render();
  }

  function choose(side){
    if(!current) return;

    // stance selection
    if(current.kind === "stance"){
      const sc = current.card;
      const stanceKey = (side === "L") ? sc.L.stanceKey : sc.R.stanceKey;
      setStance(stanceKey);

      // small immediate feel
      const st = stanceByKey(stanceKey);
      S.heat = clamp(S.heat + st.passive.heat * 2, 0, 100);
      S.health = clamp(S.health + st.passive.health * 2, 0, 100);

      save(S);
      nextCard();
      return;
    }

    // case choice
    const {card, item, chain, stage} = current;
    const choice = (side === "L") ? card.L : card.R;

    const enforce = (side === "R");
    if(enforce){
      S.streakEnforce = clamp(S.streakEnforce + 1, 0, 9);
      S.streakDeEsc = clamp(S.streakDeEsc - 1, 0, 9);
    } else {
      S.streakDeEsc = clamp(S.streakDeEsc + 1, 0, 9);
      S.streakEnforce = clamp(S.streakEnforce - 1, 0, 9);
    }

    applyFx(choice.fx);

    // baseline wear/tear
    S.health = clamp(S.health - 0.15, 0, 100);
    S.heat = clamp(S.heat + (enforce ? 0.30 : -0.10), 0, 100);

    // stance duration ticks down when you make decisions
    S.stanceTurnsLeft = Math.max(0, S.stanceTurnsLeft - 1);

    toastMsg(fxFlavor(choice.fx));

    // pursuit injection (only when allowed)
    if(!chain.isPursuit && stage === "D" && choice.lead && choice.lead.pursue){
      if(canPursue(S)){
        injectPursuit(item.ctx);
        toastMsg("Pursuit begins.");
      } else {
        toastMsg("Policy says no pursuit. You back off.");
      }
    }

    // schedule follow-ups
    if(!chain.isPursuit && stage === "E"){
      const nextShift = Math.ceil((S.turn + 1) / 14) * 14;
      if(item.chainKey === "dui" || item.chainKey === "crash"){
        schedule("court", item.ctx, nextShift + 2, "Court hits your next shift.");
      }
      if(side === "R" && chance(rng, 0.55)){
        schedule("review", item.ctx, nextShift + 3, "A review gets scheduled.");
      }
    }
    if(chain.isPursuit && stage === "P8"){
      const nextShift = Math.ceil((S.turn + 1) / 14) * 14;
      if(chance(rng, 0.45)) schedule("review", item.ctx, nextShift + 2, "Pursuit review scheduled.");
      if(chance(rng, 0.35)) schedule("court", item.ctx, nextShift + 3, "Pursuit paperwork goes to court.");
    }

    S.turn += 1;

    if(endCheck()){
      save(S);
      render();
      return;
    }

    save(S);
    nextCard();
  }

  // ---------- render ----------
  function render(){
    barPublic.style.width = `${S.public}%`; valPublic.textContent = Math.round(S.public);
    barDept.style.width   = `${S.dept}%`;   valDept.textContent   = Math.round(S.dept);
    barHealth.style.width = `${S.health}%`; valHealth.textContent = Math.round(S.health);
    barHeat.style.width   = `${S.heat}%`;   valHeat.textContent   = Math.round(S.heat);

    const {dow, shiftName} = formatTime();
    pillTime.textContent = `${dow} • Turn ${S.turn}`;
    pillZone.textContent = `Zone: ${S.zone}`;
    pillShift.textContent = `${shiftName}`;

    streakLine.textContent =
      (S.streakEnforce >= 3) ? "You’re hunting." :
      (S.streakDeEsc >= 3) ? "You’re playing it soft." : "—";

    const coreChains = CHAINS.filter(c => !c.isPursuit && !c.scheduledOnly).length;
    const cardsPerRun = coreChains * 15 + 24; // pursuit variants included
    const st = stanceByKey(S.stanceKey).label;
    footerLine.textContent = `Stance: ${st} • Cards/run ~${cardsPerRun} • Queue: ${S.queue.length} • Scheduled: ${S.scheduled.length}`;
  }

  // ---------- import/export/new run ----------
  function newRun(){
    S = DEFAULT();
    rng = mulberry32(S.seed);
    save(S);
    toastMsg("New run started.");
    nextCard(true);
  }

  function exportSave(){
    const data = JSON.stringify(S, null, 2);
    const blob = new Blob([data], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "traffic-team-save.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    toastMsg("Save exported.");
  }

  function importSave(){
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "application/json";
    input.onchange = async () => {
      const file = input.files && input.files[0];
      if(!file) return;
      try{
        const text = await file.text();
        const s = JSON.parse(text);
        if(!s || s.v !== 5) throw new Error("Bad save format");
        S = s;
        rng = mulberry32(S.seed);
        save(S);
        toastMsg("Save imported.");
        nextCard(true);
      }catch{
        toastMsg("Import failed.");
      }
    };
    input.click();
  }

  el("btnSave").onclick = () => { save(S); toastMsg("Saved."); render(); };
  el("btnNew").onclick  = () => newRun();
  el("btnExport").onclick = () => exportSave();
  el("btnImport").onclick = () => importSave();

  // ---------- PWA SW ----------
  if("serviceWorker" in navigator){
    window.addEventListener("load", async () => {
      try{ await navigator.serviceWorker.register("./sw.js"); }catch{}
    });
  }

  // ---------- boot ----------
  save(S);
  nextCard(true);
})();
</script>
</body>
</html>
